

Этот чек-лист может показаться длинным, но пункты проверяются быстро. Он помогает оценить качество кода — не найти ошибки, а выявить потенциальные проблемы. Код при этом может быть хорошо написан.

## 1. Форматирование кода

- [ ] **Выглядит хорошо**: Код визуально приятен и легко читается?
    - *Почему это важно*: Показывает, что разработчик заботится о коде.
    - *Что проверять*: Используются ли форматеры? Если нет, но код выглядит аккуратно — это хороший знак.

- [ ] **Разрыв строк**: Есть ли строки, разорванные только для соблюдения длины строки?
    - *Почему это важно*: Разорванные строки могут нарушать поток чтения и понимания.
    - *Что проверять*: Искать ненужные разрывы, особенно в комментариях или длинных строках.

- [ ] **Единый стиль**: Код отформатирован единообразно (отступы, скобки, длина строк)? Следует ли шаблонам?
    - *Почему это важно*: Единообразие улучшает читаемость и сигнализирует о внимании к деталям.
    - *Что проверять*: Искать похожий код с разным стилем. Допустимо, если код в разных модулях стилистически отличается, но в пределах одной области должен быть консистентен.

- [ ] **Уровни вложенности**: Есть ли чрезмерно вложенные блоки (глубокие отступы)?
    - *Почему это важно*: Глубокая вложенность говорит о сложной логике, которую, возможно, нужно переработать.
    - *Что проверять*: Отмечать функции с более чем 4-5 уровнями вложенности.

- [ ] **Цепочки вызовов**: Есть ли длинные цепочки методов (напр., `obj.a().b().c()`)?
    - *Почему это важно*: Длинные цепочки вызовов указывают на тесную связь, что усложняет изменение и тестирование.
    - *Что проверять*: Искать цепочки вызовов, которые можно упростить или разбить на промежуточные переменные.

- [ ] **Удобство отладки**: Включена ли в код поддержка отладки?
    - *Почему это важно*: Такой код упрощает поиск проблем и экономит время.
    - *Что проверять*: Искать отладочный код. Поняли ли авторы, как помочь другим управлять им? Есть ли временные переменные, помогающие понять поток выполнения? Assert'ы для ошибок разработчика?

## 2. Комментарии

- [ ] **Ясность**: Объясняют ли комментарии *почему* существует код, особенно для неочевидной логики?
    - *Почему это важно*: Комментарии проясняют намерения, помогая в поддержке и онбординге.
    - *Что проверять*: Убедиться, что комментарии кратки, уместны и избегают констатации очевидного (напр., `i++ // инкремент i`). Искать документацию к функциям/классам.

- [ ] **Условия и циклы**: Используются ли комментарии для объяснения сложных условий или логики, и легко ли они читаются?
    - *Почему это важно*: Сложные условия трудно понять с первого взгляда.
    - *Что проверять*: Убедиться, что комментарии разъясняют назначение сложных условий (напр., `if (x > 0 && y < 10) // Проверить, что x положительный и y меньше 10`).

## 3. Переменные

- [ ] **Осмысленные имена**: Являются ли имена переменных описательными и самодостаточными?
    - *Почему это важно*: Четкие имена уменьшают домыслы и улучшают понимание.
    - *Что проверять*: Избегать расплывчатых имен (напр., `tmp`, `data`). Предпочитать имена, специфичные для предметной области, или комбинацию типа и доменного имени (напр., `iUserAge`, `dOrderTotal`).

- [ ] **Сокращения**: Минимальны ли сокращения и широко ли они понятны?
    - *Почему это важно*: Чрезмерные или непонятные сокращения сбивают с толку.
    - *Что проверять*: Отмечать криптические сокращения (напр., `usrMngr` vs. `userManager`).

- [ ] **Область видимости и изоляция**: Объявлены ли переменные близко к месту их использования?
    - *Почему это важно*: Локализованные переменные снижают умственную нагрузку и минимизируют ошибки.
    - *Что проверять*: Искать переменные, объявленные далеко от места использования или переиспользуемые в несвязанных областях видимости.

- [ ] **Магические числа/строки**: Заменены ли жестко закодированные значения именованными константами?
    - *Почему это важно*: Магические числа (напр., `42`) скрывают intent и мешают поддержке.
    - *Что проверять*: Убедиться, что используются константы, напр., `const int MAX_USERS = 100;`.

- [ ] **Использование `auto`**: Используется ли `auto` обдуманно или он скрывает типы переменных?
    - *Почему это важно*: Чрезмерное использование `auto` может затруднить отладку, скрывая типы.
    - *Что проверять*: Убедиться, что `auto` используется в очевидных случаях (напр., итераторы, лямбды), но не там, где важна ясность типа (напр., `auto x = GetValue();`).

## 4. Плохой код

- [ ] **Множество геттеров и сеттеров**: Есть ли множество геттеров/сеттеров, которые можно упростить?
    - *Почему это важно*: Их обилие может указывать на слабую инкапсуляцию, плохой дизайн и тесную связность.
    - *Что проверять*: Искать классы с множеством тривиальных геттеров/сеттеров, которые можно заменить прямым доступом или лучшими абстракциями.

- [ ] **Прямой доступ к членам**: Есть ли случаи, когда члены класса доступны напрямую, а не через методы?
    - *Почему это важно*: Прямой доступ может нарушить инкапсуляцию и привести к проблемам с поддержкой.
    - *Что проверять*: Выявить случаи прямого доступа к членам класса (напр., `obj.member`) вместо использования методов (напр., `obj.GetMember()`).

- [ ] **Сложные выражения**: Есть ли чрезмерно сложные выражения, которые можно упростить?

## 5. Шаблоны

- [ ] **Эффективное использование**: Используются ли шаблоны для улучшения переиспользования кода без добавления сложности?
    - *Почему это важно*: Шаблоны улучшают гибкость, но могут снизить читаемость при злоупотреблении.
    - *Что проверять*: Проверить параметры шаблонов и ограничения (напр., концепты C++20). Убедиться, что они решают реальную проблему и не являются излишне обобщенными.

## 6. Наследование

- [ ] **Обоснованность**: Используется ли наследование для истинных отношений «is-a» («является»), или оно применяется чрезмерно?
    - *Почему это важно*: Неправильное использование наследования создает тесную связность, усложняя рефакторинг.
    - *Что проверять*: Убедиться, что наследование следует Принципу Подстановки Лисков. Предпочитать композицию там, где это возможно. Отмечать глубокие иерархии или конкретные базовые классы.

## 7. Псевдонимы типов (using/typedef)

- [ ] **Интуитивные имена**: Ясны ли псевдонимы и относятся к предметной области, или они скрывают смысл?
    - *Почему это важно*: Хорошие псевдонимы могут прояснить intent, но чаще сбивают с толку. Помните, что псевдонимы часто специфичны для домена, а доменные имена не всегда хороши.
    - *Что проверять*: Убедиться, что имена вроде `using Distance = double;` имеют смысл.

## 8. Методы и функции

- [ ] **Избыточное именование**: Повторяет ли имя метода имя класса или описывает его параметры без необходимости? Идентификатор метода определяется его именем и параметрами — а не пересказом того, что уже ясно.
    - *Почему это важно*: Дублирующие имена могут привести к путанице и ошибкам.
    - *Что проверять*: Убедиться, что имена методов уникальны и осмысленны без дублирования контекста класса или параметров.

- [ ] **Лаконичные имена**: Являются ли имена методов описательными, но краткими, без излишней многословности?
    - *Почему это важно*: Длинные имена (напр., `calculateTotalPriceAndApplyDiscounts`) предполагают, что метод делает слишком много.
    - *Что проверять*: Убедиться, что имена отражают единственную цель (напр., `calculateTotal`, `ApplyDiscounts`).

- [ ] **Единственная ответственность**: Выполняет ли каждый метод только одну задачу, как подразумевается его именем?
    - *Почему это важно*: Методы, выполняющие несколько задач, сложнее тестировать и поддерживать (гораздо сложнее).
    - *Что проверять*: Отмечать методы длиннее 50-60 строк или с несколькими логическими задачами.

- [ ] **Количество параметров**: Ограничено ли количество параметров метода 3-4?
    - *Почему это важно*: Слишком много параметров усложняют сигнатуры методов и их использование.
    - *Что проверять*: Искать методы с более чем 4 параметрами. Рассмотреть использование структур или классов для группировки связанных параметров.

## 9. Обработка ошибок

- [ ] **Явность и удобство отладки**: Обрабатываются ли ошибки четко?
    - *Почему это важно*: Надежная обработка ошибок предотвращает сбои и помогает при отладке.
    - *Что проверять*: Проверить единообразие механизмов обработки ошибок и корректное логирование проблем.

## 10. STL и стандартная библиотека

- [ ] **Эффективное использование**: Используется ли STL (напр., `std::vector`, `std::algorithm`) уместно? Хорошо ли код сочетается со стандартной библиотекой?
    - *Почему это важно*: Использование STL упрощает код, так как большинству C++ разработчиков она знакома. Она также хорошо продумана.
    - *Что проверять*: Искать правильное использование контейнеров, алгоритмов и современных возможностей (напр., `std::optional`, `std::string_view`). Используются ли STL-типы, такие как `value_type`, `iterator` и т.д.?

## 11. Структура файлов и проекта

- [ ] **Логическая организация**: Сгруппированы ли файлы и директории по модулям, функциям или слоям?
    - *Почему это важно*: Четкая структура упрощает навигацию и масштабируемость.
    - *Что проверять*: Проверить осмысленные имена файлов, правильное разделение заголовочных и исходных файлов, использование стражей включения (`header guards`) или `#pragma once`. Отмечать циклические зависимости.

## 12. Навигация по кодовой базе

- [ ] **Простота изучения**: Легко ли ориентироваться в коде и тестировать его?
    - *Почему это важно*: Удобная для навигации кодовая база ускоряет разработку и отладку.
    - *Что проверять*: Убедиться в четких границах модулей, consistent naming и тестируемых модулях. Проверить наличие модульных тестов для критически важной функциональности.
