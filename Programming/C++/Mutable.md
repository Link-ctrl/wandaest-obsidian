---
создал заметку: 20-04-2025
tags:
  - Плюсы
---
### Описание
Ключевое слово **`mutable`** говорит компилятору:
> «Эта переменная **может меняться**, **даже если объект `const`!»»
### Где это используется?
Когда у тебя есть **`const`-объект**, и ты хочешь **изменить его часть**,  
например:
- Кэшировать результат
- Вести статистику
- Логировать доступ
- Работать с ленивой инициализацией (lazy init)
###  Пример:
```cpp
#include <iostream>

class Counter {
public:
    mutable int accessCount = 0;

    int get() const {
        ++accessCount;  // ← разрешено, потому что поле mutable!
        return 42;
    }
};

int main() {
    const Counter c;
    std::cout << c.get() << "\n";
    std::cout << "Доступов: " << c.accessCount << "\n";
}

```
Вывод:
```cpp
42
Доступов: 1
```
### Как это работает?
- `const`-методы **не могут изменять поля объекта**
- Но если поле объявлено как `mutable`, то оно **исключено из const-проверки**
- **Только `mutable` позволяет изменять поле в `const`-методах**

|Ключевое слово|Значение|
|---|---|
|`const`|Объект не должен меняться|
|`mutable`|Это поле **можно менять даже у `const` объекта**|
### Когда не стоит использовать `mutable`?
- Когда пытаешься **обходить const не по назначению**
- Когда это можно решить другим способом (например, через `std::atomic`, `std::optional`)
### Резюме
`mutable` нужен, чтобы **разрешить менять определённые поля** **даже в `const`-методах или `const`-объектах**, когда это логически безопасно (например, кэш, статистика, ленивая загрузка).