---
создал заметку: 15-04-2025
tags:
  - Плюсы
  - Собеседования
---
### Описание
1) Препроцессинг
	**Препроцессор** — это _макро процессор_, который преобразовывает вашу программу для дальнейшего компилирования. На данной стадии происходит происходит работа с препроцессорными директивами. Например, препроцессор добавляет хэдеры в код (**#include**), убирает комментирования, заменяет макросы (**#define**) их значениями, выбирает нужные куски кода в соответствии с условиями **#if**, **#ifdef** и **#ifndef**.

	Хэдеры, включенные в программу с помощью директивы **#include**, рекурсивно проходят стадию препроцессинга и включаются в выпускаемый файл. Однако, каждый хэдер может быть открыт во время препроцессинга несколько раз, поэтому, обычно, используются специальные препроцессорные директивы, предохраняющие от циклической зависимости.

	Получим препроцессированный код в выходной файл **.ii** (прошедшие через стадию препроцессинга C++ файлы имеют расширение **.ii**), используя флаг **-E**, который сообщает компилятору, что компилировать (об этом далее) файл не нужно, а только провести его препроцессинг.
	
2) Компиляция
	На данном шаге g++ выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в _ассемблерный код_. Это промежуточный шаг между высокоуровневым языком и машинным (бинарным) кодом.

	**Ассемблерный код** — это доступное для понимания человеком представление машинного кода.

	Используя флаг **-S**, который сообщает компилятору остановиться после стадии компиляции, получим ассемблерный код в выходном файле **.s**
3) Ассемблирование
	Так как x86 процессоры исполняют команды на бинарном коде, необходимо перевести ассемблерный код в машинный с помощью **ассемблера**.

	Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в _объектном файле_.

	**Объектный файл** — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется _объектным кодом_.

	Далее возможно сохранение данного объектного кода в _статические библиотеки_ для того, чтобы не компилировать данный код снова.

	Получим машинный код с помощью ассемблера (**as**) в выходной объектный файл **.o**:
4) Компоновка (линковка)
	**Компоновщик (линкер)** связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. Для того, чтобы понять как происходит связка, следует рассказать о _таблице символов_.

	**Таблица символов** — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на данные и процедуры в других объектных файлах.  
	Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет способен в дальнейшем построить связи между данными среди множества других объектных файлов и создать единый исполняемый файл из них.
	
	Получим исполняемый файл
5) Загрузка
	Последний этап, который предстоит пройти нашей программе — вызвать загрузчик для загрузки нашей программы в память. На данной стадии также возможна подгрузка _динамических библиотек_.