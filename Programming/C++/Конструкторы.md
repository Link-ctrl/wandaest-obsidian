---
создал заметку: 2025-04-20
tags:
  - Плюсы
---
### Описание
## Какие **виды конструкторов** бывают в C++?

### 1. **Конструктор по умолчанию (default constructor)**

- Не принимает аргументов или все аргументы имеют значения по умолчанию.
```cpp
class A {
public:
    A() { cout << "Default\n"; }
};

```

### 2. **Конструктор копирования (copy constructor)**

- Принимает `const A&` и **создаёт копию** объекта.
```cpp
class A {
public:
    A(const A& other) { cout << "Copy\n"; }
};
```

### 3. **Конструктор перемещения (move constructor)**

- Принимает `A&&` и **перемещает** ресурсы (например, указатели).

```cpp
class A {
public:
    A(A&& other) { cout << "Move\n"; }
};
```

### 4. **Пользовательский конструктор (custom constructor)**
- С аргументами, задающими значения при создании.

```cpp
class A {
public:
    A(int x, string name) { ... }
};
```
### 5. **Конструктор со списком инициализации**
- Использует `: x(val), y(val)` для инициализации полей до входа в тело.
```cpp
class A {
    int x;
public:
    A(int val) : x(val) {}
};
```
### 6. **Делегирующий конструктор (delegating)**
- Один конструктор вызывает другой конструктора этого же класса.
```cpp
class A {
public:
    A() : A(42) {} // вызывает A(int)
    A(int x) { ... }
};
```

### 7. **Конструктор со списком инициализации std::initializer_list**
- Позволяет инициализировать через фигурные скобки.
```cpp
class A {
public:
    A(std::initializer_list<int> list) { ... }
};
A a = {1, 2, 3}; // вызывает этот конструктор
```

## Может ли **конструктор быть виртуальным**?
**Нет, НИКОГДА.**
### Почему?
- Конструктор вызывается **до** того, как создан объект.
- А виртуальный механизм требует, чтобы объект **уже существовал** и имел vtable.
- У конструктора нет объекта → **нет vtable → нет виртуальности**.

## А вот **деструктор** — **МОЖЕТ быть виртуальным*. И даже **ДОЛЖЕН** быть в базовом классе с полиморфизмом.
### Зачем делать деструктор виртуальным?
Чтобы при удалении **через указатель на базовый класс**,  
**вызвался правильный деструктор производного класса**.

Пример без виртуального деструктора:
```cpp
class Base {
public:
    ~Base() { cout << "Base dtor\n"; }
};
class Derived : public Base {
public:
    ~Derived() { cout << "Derived dtor\n"; }
};

Base* ptr = new Derived;
delete ptr; // ❌ Только Base::~Base(), утечка ресурсов!

```
С виртуальным деструктором:
```cpp
class Base {
public:
    virtual ~Base() { cout << "Base dtor\n"; }
};
```
Теперь при `delete ptr`, вызовется:
```cpp
Derived::~Derived() → Base::~Base()
```
### Когда **НУЖЕН виртуальный деструктор**?
- Класс имеет **виртуальные методы**
- Класс **используется как базовый**
- Класс удаляется **через указатель на базу**

