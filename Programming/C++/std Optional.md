---
создал заметку: 19-04-2025
tags:
  - Плюсы
---
### Описание
**`std::optional<T>`** — это обёртка, которая говорит:

> "**Значение может быть, а может и не быть** — и это **не ошибка**, а **легальный вариант**."
### Применение:
Используется, когда:
- **Нельзя вернуть значение? — возвращай `std::nullopt`**
- **Есть вероятность, что результата не будет**
- **Хочешь избежать `nullptr`, `bool`-флагов и `exceptions`**
- **Функция может "не найти" / "не посчитать" / "не выбрать" и т.д.**

### Простой пример:
```cpp
#include <optional>
#include <iostream>

std::optional<int> divide(int a, int b) {
    if (b == 0) return std::nullopt;
    return a / b;
}

int main() {
    auto result = divide(10, 2);
    if (result)
        std::cout << "Result: " << *result << "\n";
    else
        std::cout << "Division by zero!\n";
}
```
Вывод: `Result: 5`
### Поведение:
- У `optional<T>` есть состояние: **"значение есть"** или **"значения нет"**
- Чтобы проверить: `if (opt)` или `opt.has_value()`
- Чтобы получить: `*opt`, `opt.value()` или `opt.value_or(default)`
### Осторожно:
- `optional<T>` **всегда копирует/перемещает `T`**, если ты не используешь ссылки (`optional<T&>` с C++23)
- `value()` бросает исключение, если значения нет
- Не злоупотребляй: `optional` не заменяет всю обработку ошибок

### Резюме
`std::optional<T>` — это **безопасный контейнер для "может быть значения"**,  
который делает **код читаемым, явным и без `nullptr` и `try/catch`.**

