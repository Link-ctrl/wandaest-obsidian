---
создал заметку: 22-04-2025
tags:
  - База
---
### Описание
**Инкапсуляция** — это **принцип ООП**, согласно которому:
> **Данные и поведение объединяются в единый объект**,  
> а **внутреннее состояние скрыто от внешнего мира** и доступно **только через строго определённый интерфейс**.
### Главная цель инкапсуляции:
- Защитить объект от **неправильного или опасного использования**
- Позволить менять реализацию **без влияния на внешний код**
- Сдерживать **сложность** внутри класса

Пример:
```cpp
class BankAccount {
private:
    double balance = 0; // закрыто!

public:
    void deposit(double amount) {
        if (amount > 0) balance += amount;
    }

    void withdraw(double amount) {
        if (amount > 0 && amount <= balance) balance -= amount;
    }

    double getBalance() const {
        return balance;
    }
};
```
#### `balance` — **инкапсулировано**:
- снаружи **нельзя изменить напрямую** (`account.balance = -100;` — ошибка!)
- можно только через **методы** `deposit()` / `withdraw()`, которые **контролируют поведение**
### В C++ инкапсуляция реализуется через **модификаторы доступа**:

|Ключевое слово|Доступ к членам класса|
|---|---|
|`private`|Только внутри этого класса|
|`protected`|Внутри класса и у его потомков|
|`public`|Доступен отовсюду|
### Как использовать инкапсуляцию грамотно:
- Всегда делай **данные `private` или `protected`**
- Предоставляй **узкий, чёткий `public`-интерфейс`**
- Не давай `setX()` без логики: лучше `updateX()` с валидацией
- Делай поля `const`, если они не должны меняться после инициализации

|Что|Суть|
|---|---|
|**Абстракция**|Скрыть **детали**, оставить только **суть взаимодействия**|
|**Инкапсуляция**|Скрыть **внутреннее состояние** и **поведение**, дать интерфейс управления|
### Примеры в стандартной библиотеке:
- `std::vector::size()` — доступ к размеру, но ты **не можешь напрямую лезть в поля**
- `std::thread` — ты **не видишь**, как устроен поток, но можешь его `join()` / `detach()`
### Резюме
✅ Управление доступом к данным  
✅ Контроль за состоянием объекта  
✅ Простота и безопасность  
✅ Независимость от реализации  
✅ Устойчивость к ошибкам